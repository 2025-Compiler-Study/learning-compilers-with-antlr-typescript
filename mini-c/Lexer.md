# MiniC Lexer 명세

MiniC는 C 언어의 부분집합으로, ANTLR4를 사용하여 구현됩니다.

## 1. 키워드 (Keywords)

MiniC에서 예약된 키워드들:

- **타입**: `int`, `void`, `char`
- **제어문**: `if`, `else`, `while`, `for`, `return`
- **기타**: `break`, `continue`

## 2. 식별자 (Identifiers)

- 영문자(a-z, A-Z) 또는 밑줄(\_)로 시작
- 이후에는 영문자, 숫자(0-9), 밑줄(\_) 사용 가능
- 키워드는 식별자로 사용 불가
- 예: `x`, `count`, `_temp`, `myVariable`

## 3. 리터럴 (Literals)

### 3.1 정수 리터럴 (Integer Literals)

- 10진수: `0`, `123`, `4567`
- 음수는 단항 연산자로 처리 (예: `-123`)

### 3.2 문자 리터럴 (Character Literals)

- 작은따옴표로 묶임: `'a'`, `'1'`, `'?'`
- 이스케이프 시퀀스 지원: `'\n'`, `'\t'`, `'\\'`, `'\''`

### 3.3 문자열 리터럴 (String Literals)

- 큰따옴표로 묶임: `"hello"`, `"world"`
- 이스케이프 시퀀스 지원: `"\n"`, `"\t"`, `"\\"`, `"\""`

## 4. 연산자 (Operators)

### 4.1 산술 연산자

- `+` (덧셈)
- `-` (뺄셈)
- `*` (곱셈)
- `/` (나눗셈)
- `%` (나머지)

### 4.2 관계 연산자

- `==` (같음)
- `!=` (다름)
- `<` (작음)
- `>` (큼)
- `<=` (작거나 같음)
- `>=` (크거나 같음)

### 4.3 논리 연산자

- `&&` (논리 AND)
- `||` (논리 OR)
- `!` (논리 NOT)

### 4.4 대입 연산자

- `=` (대입)

### 4.5 증감 연산자

- `++` (증가)
- `--` (감소)

## 5. 구분자 (Delimiters)

- `(` `)` - 괄호
- `{` `}` - 중괄호
- `[` `]` - 대괄호
- `;` - 세미콜론
- `,` - 쉼표

## 6. 주석 (Comments)

### 6.1 한 줄 주석

- `//`로 시작하여 줄 끝까지

### 6.2 여러 줄 주석

- `/*`로 시작하여 `*/`로 종료

## 7. 공백 (Whitespace)

- 스페이스 (` `)
- 탭 (`\t`)
- 줄바꿈 (`\n`, `\r`, `\r\n`)
- Lexer에서 무시됨

## 8. 토큰 우선순위 규칙

1. 주석이 가장 먼저 처리되어 제거됨
2. 키워드가 식별자보다 우선
3. 긴 연산자가 짧은 연산자보다 우선 (예: `==`이 `=`보다 먼저 매칭)
4. 공백은 토큰 구분자 역할만 하고 무시됨

## 9. 에러 처리

- 정의되지 않은 문자나 잘못된 토큰은 에러로 처리
- 닫히지 않은 문자열이나 주석은 에러

## 구현 목표

### 10.1 Longest Matching 원칙 체험하기

**원칙**: 토큰이 2개 이상 겹칠 때, 가장 긴 것과 매칭됩니다.

**테스트 케이스**:
1. 연산자: `=` vs `==`, `+` vs `++`, `-` vs `--`, `<` vs `<=`, `>` vs `>=`, `!` vs `!=`
2. 키워드 vs 식별자: `int` vs `integer`, `for` vs `fork`, `if` vs `ifx`, `while` vs `whilex`

### 10.2 토큰화와 파싱의 차이 이해하기

**핵심**: Lexer는 "어떤 토큰들이 있는가?"만 판단, Parser는 "토큰의 순서와 조합이 올바른가?"를 판단

**테스트 케이스** (파싱 오류지만 토큰화는 성공):
```c
// 정상: int main()
// 오류: main() int

// 정상: int x = 5;
// 오류: = int 5 x ;

// 정상: if (x > 0) return 1;
// 오류: return if 1 (x > 0);
```

→ 순서와 구조가 잘못되어도 개별 토큰은 모두 유효하므로 Lexer는 성공합니다.
