# MiniC Lexer 명세

MiniC는 C 언어의 부분집합으로, ANTLR4를 사용하여 구현됩니다.

## 1. 키워드 (Keywords)

MiniC에서 예약된 키워드들:

- **타입**: `int`, `void`
- **상수 선언**: `const`
- **제어문**: `if`, `else`, `while`, `return`
- **내장함수**: `read`, `write`

## 2. 식별자 (Identifiers)

- 영문자(a-z, A-Z) 또는 밑줄(\_)로 시작
- 이후에는 영문자, 숫자(0-9), 밑줄(\_) 사용 가능
- 키워드는 식별자로 사용 불가
- 예: `x`, `count`, `_temp`, `myVariable`

## 3. 리터럴 (Literals)

### 3.1 정수 리터럴 (Integer Literals)

MiniC는 ANSI C 표기법을 따라 다음 진법을 지원합니다:

- **10진수**: `0`, `123`, `4567`
- **8진수**: `0`으로 시작 (예: `0777`, `0123`)
- **16진수**: `0x` 또는 `0X`로 시작 (예: `0xFF`, `0x1A3`, `0X2B`)
- 음수는 단항 연산자로 처리 (예: `-123`, `-0xFF`)

## 4. 연산자 (Operators)

### 4.1 산술 연산자

- `+` (덧셈)
- `-` (뺄셈)
- `*` (곱셈)
- `/` (나눗셈)
- `%` (나머지)

### 4.2 관계 연산자

- `==` (같음)
- `!=` (다름)
- `<` (작음)
- `>` (큼)
- `<=` (작거나 같음)
- `>=` (크거나 같음)

### 4.3 논리 연산자

- `&&` (논리 AND)
- `||` (논리 OR)
- `!` (논리 NOT)

### 4.4 대입 연산자

- `=` (대입)
- `+=` (덧셈 후 대입)
- `-=` (뺄셈 후 대입)
- `*=` (곱셈 후 대입)
- `/=` (나눗셈 후 대입)
- `%=` (나머지 후 대입)

### 4.5 증감 연산자

- `++` (증가) - 전위표기(`++i`)와 후위표기(`i++`) 모두 지원
- `--` (감소) - 전위표기(`--i`)와 후위표기(`i--`) 모두 지원

## 5. 구분자 (Delimiters)

- `(` `)` - 괄호
- `{` `}` - 중괄호
- `[` `]` - 대괄호
- `;` - 세미콜론
- `,` - 쉼표

## 6. 주석 (Comments)

### 6.1 한 줄 주석

- `//`로 시작하여 줄 끝까지

### 6.2 여러 줄 주석

- `/*`로 시작하여 `*/`로 종료

## 7. 공백 (Whitespace)

- 스페이스 (` `)
- 탭 (`\t`)
- 줄바꿈 (`\n`, `\r`, `\r\n`)
- Lexer에서 무시됨

## 8. 토큰 우선순위 규칙

1. 주석이 가장 먼저 처리되어 제거됨
2. 키워드가 식별자보다 우선
3. 긴 연산자가 짧은 연산자보다 우선 (예: `==`이 `=`보다, `+=`가 `+`보다 먼저 매칭)
4. 정수 리터럴: 16진수(`0x`) → 8진수(`0`) → 10진수 순으로 매칭
5. 공백은 토큰 구분자 역할만 하고 무시됨

## 9. 변수 및 상수 선언 규칙

### 9.1 변수 선언
- 자료형: **정수형(`int`)**, **정수형 고정 길이 배열**만 지원
- 변수 선언 시 즉시 값 초기화 불가 (예: `int x;`는 가능, `int x = 5;`는 불가)
- 한 줄에 `,`를 사용하여 여러 변수 동시 선언 가능 (예: `int x, y, z;`)
- 배열 선언: `int arr[10];` 또는 `int arr[SIZE];` (상수 변수 사용 가능)

### 9.2 상수 선언
- `const` 키워드 사용
- 상수 선언 시 즉시 값 초기화 필수 (예: `const int SIZE = 100;`)

## 10. 사칙연산 우선순위 및 제약

- 사칙연산은 기초적인 우선순위를 따름: `*`, `/`, `%` > `+`, `-`
- **괄호를 통한 우선순위 변경은 제공하지 않음** (단, 흐름제어 조건식에서 `()`는 사용)
- 우선순위가 동일한 경우 왼쪽에서 오른쪽으로 계산 (좌결합)

## 11. 흐름제어

- 조건문: `if`, `if-else`만 지원 (`else if`, `switch` 미지원)
- 반복문: `while`만 지원 (`for`, `do-while` 미지원)
- 조건 부분은 `()`로 감싸서 구분 (예: `if (x > 0)`, `while (i < 10)`)

## 12. 함수

- 함수 정의: `반환타입 함수명(인자) { 함수내용 }` (ANSI C 형식)
- 함수 선언/정의는 사용 지점 이전이나 이후 어디든 가능
- 모든 함수 인자는 **call-by-reference** 방식으로 전달
- 내장함수: `read`, `write` (변수 값 입력/출력)

## 13. 에러 처리

- 정의되지 않은 문자나 잘못된 토큰은 에러로 처리
- 닫히지 않은 주석은 에러

## 14. 구현 목표

### 14.1 Longest Matching 원칙 체험하기

**원칙**: 토큰이 2개 이상 겹칠 때, 가장 긴 것과 매칭됩니다.

**테스트 케이스**:
1. 연산자: `=` vs `==`, `+` vs `++` vs `+=`, `-` vs `--` vs `-=`, `<` vs `<=`, `>` vs `>=`, `!` vs `!=`
2. 정수 리터럴: `0` vs `0x` vs `077` (10진수 vs 16진수 vs 8진수)
3. 키워드 vs 식별자: `int` vs `integer`, `const` vs `constant`, `if` vs `ifx`, `while` vs `whilex`

### 14.2 토큰화와 파싱의 차이 이해하기

**핵심**: Lexer는 "어떤 토큰들이 있는가?"만 판단, Parser는 "토큰의 순서와 조합이 올바른가?"를 판단

**테스트 케이스** (파싱 오류지만 토큰화는 성공):
```c
// 정상: int main()
// 오류: main() int

// 정상: int x;
// 오류: x int ;

// 정상: const int SIZE = 100;
// 오류: int const = SIZE 100;

// 정상: if (x > 0) return 1;
// 오류: return if 1 (x > 0);

// 정상: while (i < 10) i++;
// 오류: i++ (i < 10) while;
```

→ 순서와 구조가 잘못되어도 개별 토큰은 모두 유효하므로 Lexer는 성공합니다.

## 15. 문장 종료 및 구조

- 상수/변수 선언, 값 연산 문장은 `;`로 종료
- 흐름제어(if, while)와 함수 정의는 `{}`로 블록 구성
- 주석: C89의 `/* */` 방식과 C++의 `//` 방식 모두 지원
